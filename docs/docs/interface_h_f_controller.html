<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>HexFiend: HFController Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>HFController Class Reference<br>
<small>
[<a class="el" href="group__controller.html">Controller</a>]</small>
</h1><!-- doxytag: class="HFController" -->A central class that acts as the controller layer for HexFiend.framework.  
<a href="#_details">More...</a>
<p>

<p>
<a href="class_h_f_controller-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Representer handling.</div></td></tr>
<tr><td colspan="2"><div class="groupText">Methods for modifying the list of HFRepresenters attached to a controller. Attached representers receive the controllerDidChange: message when various properties of the controller change. A representer may only be attached to one controller at a time. Representers are retained by the controller. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#7eb072b7be811de79dc02a61d8e3cf3c">representers</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#d73e4ffe460788bcd9eb92ce787e1bb3">addRepresenter:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#86c8210e506241fd9ffcf1178ccda638">removeRepresenter:</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Property transactions</div></td></tr>
<tr><td colspan="2"><div class="groupText">Methods for temporarily delaying notifying representers of property changes. There is a property transaction stack, and all property changes are collected until the last token is popped off the stack, at which point all representers are notified of all collected changes via representerChangedProperties:. To use this, call beginPropertyChangeTransaction, and record the token that is returned. Pass it to endPropertyChangeTransaction: to notify representers of all changed properties in bulk.<p>
Tokens cannot be popped out of order - they are used only as a correctness check. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSUInteger)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#e06e532a971d22fdbee319e6d945dfc0">beginPropertyChangeTransaction</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#bd125ad02e37fdfe9717009802299521">endPropertyChangeTransaction:</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Byte array</div></td></tr>
<tr><td colspan="2"><div class="groupText">Set and get the byte array. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#ea808ed6a9ebc5d8ee9304198d4e51ca">setByteArray:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#3a705c6160dd66ff9ff7523d30a43d30">byteArray</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#ce0be446660da37a3cdb792147eb4450">replaceByteArray:</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Properties shared between all representers</div></td></tr>
<tr><td colspan="2"><div class="groupText">The following properties are considered global among all HFRepresenters attached to the receiver. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(unsigned long long)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#0d622d3c4081ac3d02c31ea10b7e36e0">totalLineCount</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSUInteger)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#ed984819ab1e75a22e77b6635fcd4fac">bytesPerLine</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(CGFloat)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#75054d2f63731ef1a7929a2ea3b085d9">lineHeight</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Selection pulsing</div></td></tr>
<tr><td colspan="2"><div class="groupText">Used to show the current selection after a change, similar to Find in Safari <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#bf7e8cacb521993742fd88db9a9ef77e">pulseSelection</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(double)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#880de2a78166ed64f22643e7f71428ea">selectionPulseAmount</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Selection handling</div></td></tr>
<tr><td colspan="2"><div class="groupText">Methods for manipulating the current selected ranges. Hex Fiend supports discontiguous selection. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#ea6e81942785c6c9c686992ee57f9daa">selectedContentsRanges</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#022574c9d08698c2332c66cd14379d97">setSelectedContentsRanges:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(IBAction)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#aba68329641a7b726a5ce15a6497b5c5">selectAll:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(unsigned long long)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#93786a0f5d77922ebd0ff33ec86cf619">minimumSelectionLocation</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(unsigned long long)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#49bbc9b470ded0129647c4f8e43f3238">maximumSelectionLocation</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#7fbfe5277deb412a9cf30e4d23768d6a">byteArrayForSelectedContentsRanges</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Bytes per column</div></td></tr>
<tr><td colspan="2"><div class="groupText">Set and get the number of bytes per column. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#4a075b5f9672ed591f4df05b529523ea">setBytesPerColumn:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSUInteger)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#21b45695d698577bc77f240b4934d84e">bytesPerColumn</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Overwrite mode</div></td></tr>
<tr><td colspan="2"><div class="groupText">Determines whether text insertion overwrites subsequent text or not. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#29520367fc6936a7bea9d2666c048f53">inOverwriteMode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#8b5d220244a6172965dd77a988ac10a2">setInOverwriteMode:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#81a19f92ea49ee1a1099219d3b02f7db">requiresOverwriteMode</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Displayed line range</div></td></tr>
<tr><td colspan="2"><div class="groupText">Methods for setting and getting the current range of displayed lines. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(<a class="el" href="struct_h_f_f_p_range.html">HFFPRange</a>)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#62c0d350b8f9e5c0e35e1c676f9198b1">displayedLineRange</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#cccd8b4479f2d5f9412e3264fade0bfd">setDisplayedLineRange:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#56a018dd37edf85c0827b1ddb8033c1e">maximizeVisibilityOfContentsRange:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#1f6f628d0e41ad0f9d08fcb6e4859ff6">centerContentsRange:</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Font</div></td></tr>
<tr><td colspan="2"><div class="groupText">Get and set the current font. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSFont *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#78f0706546173a0520e100a1aef3d96a">font</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#c18fa5735f1e007ca0afaed4d681ee0e">setFont:</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Undo management</div></td></tr>
<tr><td colspan="2"><div class="groupText">Get and set the undo manager. If no undo manager is set, then undo is not supported. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#d1e7a80670e75a7a52e3c661e561f504">setUndoManager:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSUndoManager *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#b8e21f45fb081eb89144c84c63e4a969">undoManager</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Editability</div></td></tr>
<tr><td colspan="2"><div class="groupText">Set and get whether representers should allow editing the data. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#95b2d736476d323636a032a67e31567f">editable</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#c7b5cc18a47905b21f68e6a38602eacc">setEditable:</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Antialiasing</div></td></tr>
<tr><td colspan="2"><div class="groupText">Set and get whether the text should be antialiased. Note that Mac OS X settings may prevent antialiasing text below a certain point size. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#c9daafc45d20b23aee996967db8ff95a">shouldAntialias</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#e19015e1d86a43569d9a8d70e01fa4a2">setShouldAntialias:</a></td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#897adf82206ac7ff51d88d682c75adb5">representer:changedProperties:</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Mouse selection</div></td></tr>
<tr><td colspan="2"><div class="groupText">Methods to handle mouse selection. Representers that allow text selection should call beginSelectionWithEvent:forByteIndex: upon receiving a mouseDown event, and then continueSelectionWithEvent:forByteIndex: for mouseDragged events, terminating with endSelectionWithEvent:forByteIndex: upon receiving the mouse up. <a class="el" href="interface_h_f_controller.html" title="A central class that acts as the controller layer for HexFiend.framework.">HFController</a> will compute the correct selected ranges and propagate any changes via the HFControllerPropertyBits mechanism. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#fe1ed1781c43e90cd22ac7b2a8f075cd">beginSelectionWithEvent:forByteIndex:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#fef0697a95acb2993f3130fe06e33d1c">continueSelectionWithEvent:forByteIndex:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#2334cbd36d1c2db533b923dee6dd6227">endSelectionWithEvent:forByteIndex:</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Scrollling</div></td></tr>
<tr><td colspan="2"><div class="groupText">Support for the mouse wheel and scroll bars. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#d360138919e9089c6edd7868a318bb93">scrollWithScrollEvent:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#101555ad8fbdad75022ba0ad59c43cc3">scrollByLines:</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Keyboard navigation</div></td></tr>
<tr><td colspan="2"><div class="groupText">Support for chaging the selection via the keyboard <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#1c9891714d90d45b21443183f3e18612">moveInDirection:byByteCount:withSelectionTransformation:usingAnchor:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#f55799f6dcf1e8ea6d52a63d11913e4d">moveInDirection:withGranularity:andModifySelection:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#2d2eea7b16f6fd019f949cdbf953a2d4">moveToLineBoundaryInDirection:andModifySelection:</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Text editing</div></td></tr>
<tr><td colspan="2"><div class="groupText">Methods to support common text editing operations <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#14b1e57bd37c4b9b4f7efc78feff5cc7">insertByteArray:replacingPreviousBytes:allowUndoCoalescing:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#699f5ef88349ffda1475e7a18b072f30">insertData:replacingPreviousBytes:allowUndoCoalescing:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#f00b1ffb077f9a69e4e81271e2326a65">deleteSelection</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#3ab4cca9b78f0d7654a7a47a8f5d3348">deleteDirection:</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Reading data</div></td></tr>
<tr><td colspan="2"><div class="groupText">Methods for reading data <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSData *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#1cde2c2c601a6093183bf5d46744e41c">dataForRange:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#a2079ff054de49c61e2ac36f8db046e0">copyBytes:range:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(<a class="el" href="interface_h_f_byte_range_attribute_array.html">HFByteRangeAttributeArray</a> *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#e6f97f85a07846c175eec9d120b7ab0c">byteRangeAttributeArray</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(<a class="el" href="interface_h_f_byte_range_attribute_array.html">HFByteRangeAttributeArray</a> *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#ee334d276545d87999f50068d92fdbc9">attributesForBytesInRange:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#f9c1dd8642e2699e3905607af4baebda">rangeForBookmark:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#e422bac1d7fa0bd6a23af4da72bdb659">setRange:forBookmark:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSIndexSet *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#2d070cf8360a9a5caf0ecabcb68e826e">bookmarksInRange:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(unsigned long long)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#63873f2b9439048b9ba1c406ec033b44">contentsLength</a></td></tr>

<tr><td colspan="2"><br><h2>File writing dependency handling</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_controller.html#73c224051475a997711192269714a0bf">clearUndoManagerDependenciesOnRanges:inFile:hint:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_h_f_controller.html#1a11f43ce26f5c2dbfcf447d6c5470eb">prepareForChangeInFile:fromWritingByteArray:</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="interface_h_f_controller.html" title="A central class that acts as the controller layer for HexFiend.framework.">HFController</a> acts as the controller layer in the MVC architecture of HexFiend. The <a class="el" href="interface_h_f_controller.html" title="A central class that acts as the controller layer for HexFiend.framework.">HFController</a> plays several significant central roles, including:<ul>
<li>Mediating between the data itself (in the <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a>) and the views of the data (the <a class="el" href="interface_h_f_representer.html">HFRepresenters</a>).</li><li>Propagating changes to the views.</li><li>Storing properties common to all Representers, such as the currently diplayed range, the currently selected range(s), the font, etc.</li><li>Handling text editing actions, such as selection changes or insertions/deletions.</li></ul>
<p>
An <a class="el" href="interface_h_f_controller.html" title="A central class that acts as the controller layer for HexFiend.framework.">HFController</a> is the top point of ownership for a HexFiend object graph. It retains both its ByteArray (model) and its array of Representers (views).<p>
You create an <a class="el" href="interface_h_f_controller.html" title="A central class that acts as the controller layer for HexFiend.framework.">HFController</a> via <code>[[<a class="el" href="interface_h_f_controller.html" title="A central class that acts as the controller layer for HexFiend.framework.">HFController</a> alloc] init]</code>. After that, give it an <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a> via setByteArray:, and some Representers via addRepresenter:. Then insert the Representers' views in a window, and you're done. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="7eb072b7be811de79dc02a61d8e3cf3c"></a><!-- doxytag: member="HFController::representers" ref="7eb072b7be811de79dc02a61d8e3cf3c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) representers           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the current array of representers attached to this controller. 
</div>
</div><p>
<a class="anchor" name="d73e4ffe460788bcd9eb92ce787e1bb3"></a><!-- doxytag: member="HFController::addRepresenter:" ref="d73e4ffe460788bcd9eb92ce787e1bb3" args="(HFRepresenter *representer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addRepresenter:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_representer.html">HFRepresenter</a> *)&nbsp;</td>
          <td class="paramname"> <em>representer</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a new representer to this controller. 
</div>
</div><p>
<a class="anchor" name="86c8210e506241fd9ffcf1178ccda638"></a><!-- doxytag: member="HFController::removeRepresenter:" ref="86c8210e506241fd9ffcf1178ccda638" args="(HFRepresenter *representer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeRepresenter:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_representer.html">HFRepresenter</a> *)&nbsp;</td>
          <td class="paramname"> <em>representer</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes an existing representer from this controller. The representer must be present in the array of representers. 
</div>
</div><p>
<a class="anchor" name="e06e532a971d22fdbee319e6d945dfc0"></a><!-- doxytag: member="HFController::beginPropertyChangeTransaction" ref="e06e532a971d22fdbee319e6d945dfc0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSUInteger) beginPropertyChangeTransaction           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins delaying property change transactions. Returns a token that should be passed to endPropertyChangeTransactions:. 
</div>
</div><p>
<a class="anchor" name="bd125ad02e37fdfe9717009802299521"></a><!-- doxytag: member="HFController::endPropertyChangeTransaction:" ref="bd125ad02e37fdfe9717009802299521" args="(NSUInteger token)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) endPropertyChangeTransaction:           </td>
          <td></td>
          <td class="paramtype">(NSUInteger)&nbsp;</td>
          <td class="paramname"> <em>token</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pass a token returned from beginPropertyChangeTransaction to this method to pop the transaction off the stack and, if the stack is empty, to notify Representers of all collected changes. Tokens cannot be popped out of order - they are used strictly as a correctness check. 
</div>
</div><p>
<a class="anchor" name="ea808ed6a9ebc5d8ee9304198d4e51ca"></a><!-- doxytag: member="HFController::setByteArray:" ref="ea808ed6a9ebc5d8ee9304198d4e51ca" args="(HFByteArray *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setByteArray:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *)&nbsp;</td>
          <td class="paramname"> <em>val</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the byte array for the <a class="el" href="interface_h_f_controller.html" title="A central class that acts as the controller layer for HexFiend.framework.">HFController</a>. The byte array must be non-nil. 
</div>
</div><p>
<a class="anchor" name="3a705c6160dd66ff9ff7523d30a43d30"></a><!-- doxytag: member="HFController::byteArray" ref="3a705c6160dd66ff9ff7523d30a43d30" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *) byteArray           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the byte array for the <a class="el" href="interface_h_f_controller.html" title="A central class that acts as the controller layer for HexFiend.framework.">HFController</a>. In general, HFRepresenters should not use this to determine what bytes to display. Instead they should use copyBytes:range: or dataForRange: below. 
</div>
</div><p>
<a class="anchor" name="ce0be446660da37a3cdb792147eb4450"></a><!-- doxytag: member="HFController::replaceByteArray:" ref="ce0be446660da37a3cdb792147eb4450" args="(HFByteArray *newArray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) replaceByteArray:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *)&nbsp;</td>
          <td class="paramname"> <em>newArray</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replaces the entire byte array with a new one, preserving as much of the selection as possible. Unlike setByteArray:, this method is undoable, and intended to be used from representers that make a global change (such as Replace All). 
</div>
</div><p>
<a class="anchor" name="0d622d3c4081ac3d02c31ea10b7e36e0"></a><!-- doxytag: member="HFController::totalLineCount" ref="0d622d3c4081ac3d02c31ea10b7e36e0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (unsigned long long) totalLineCount           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of lines on which the cursor may be placed. This is always at least 1, and is equivalent to (unsigned long long)(HFRoundUpToNextMultiple(contentsLength, bytesPerLine) / bytesPerLine) 
</div>
</div><p>
<a class="anchor" name="ed984819ab1e75a22e77b6635fcd4fac"></a><!-- doxytag: member="HFController::bytesPerLine" ref="ed984819ab1e75a22e77b6635fcd4fac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSUInteger) bytesPerLine           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates the number of bytes per line, which is a global property among all the line-oriented representers. 
</div>
</div><p>
<a class="anchor" name="75054d2f63731ef1a7929a2ea3b085d9"></a><!-- doxytag: member="HFController::lineHeight" ref="75054d2f63731ef1a7929a2ea3b085d9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (CGFloat) lineHeight           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the height of a line, in points. This is generally determined by the font. Representers that wish to align things to lines should use this. 
</div>
</div><p>
<a class="anchor" name="bf7e8cacb521993742fd88db9a9ef77e"></a><!-- doxytag: member="HFController::pulseSelection" ref="bf7e8cacb521993742fd88db9a9ef77e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) pulseSelection           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins selection pulsing (e.g. following a successful Find operation). Representers will receive callbacks indicating that HFControllerSelectionPulseAmount has changed. 
</div>
</div><p>
<a class="anchor" name="880de2a78166ed64f22643e7f71428ea"></a><!-- doxytag: member="HFController::selectionPulseAmount" ref="880de2a78166ed64f22643e7f71428ea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (double) selectionPulseAmount           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the amount that the "Find pulse indicator" should show. 0 means no pulse, 1 means maximum pulse. This is useful for Representers that support find and replace. 
</div>
</div><p>
<a class="anchor" name="ea6e81942785c6c9c686992ee57f9daa"></a><!-- doxytag: member="HFController::selectedContentsRanges" ref="ea6e81942785c6c9c686992ee57f9daa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) selectedContentsRanges           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an array of HFRangeWrappers, representing the selected ranges. This method always contains at least one range. If there is no selection, then the result will contain a single range of length 0, with the location equal to the position of the cursor. 
</div>
</div><p>
<a class="anchor" name="022574c9d08698c2332c66cd14379d97"></a><!-- doxytag: member="HFController::setSelectedContentsRanges:" ref="022574c9d08698c2332c66cd14379d97" args="(NSArray *selectedRanges)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setSelectedContentsRanges:           </td>
          <td></td>
          <td class="paramtype">(NSArray *)&nbsp;</td>
          <td class="paramname"> <em>selectedRanges</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Explicitly set the selected contents ranges. Pass an array of HFRangeWrappers that meets the following criteria: The array must not be NULL. There always must be at least one selected range. If any range has length 0, there must be exactly one selected range. No range may extend beyond the contentsLength, with the exception of a single zero-length range, which may be at the end. 
</div>
</div><p>
<a class="anchor" name="aba68329641a7b726a5ce15a6497b5c5"></a><!-- doxytag: member="HFController::selectAll:" ref="aba68329641a7b726a5ce15a6497b5c5" args="(id sender)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (IBAction) selectAll:           </td>
          <td></td>
          <td class="paramtype">(id)&nbsp;</td>
          <td class="paramname"> <em>sender</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Selects the entire contents. 
</div>
</div><p>
<a class="anchor" name="93786a0f5d77922ebd0ff33ec86cf619"></a><!-- doxytag: member="HFController::minimumSelectionLocation" ref="93786a0f5d77922ebd0ff33ec86cf619" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (unsigned long long) minimumSelectionLocation           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the smallest value in the selected contents ranges, or the insertion location if the selection is empty. 
</div>
</div><p>
<a class="anchor" name="49bbc9b470ded0129647c4f8e43f3238"></a><!-- doxytag: member="HFController::maximumSelectionLocation" ref="49bbc9b470ded0129647c4f8e43f3238" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (unsigned long long) maximumSelectionLocation           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the largest HFMaxRange of the selected contents ranges, or the insertion location if the selection is empty. 
</div>
</div><p>
<a class="anchor" name="7fbfe5277deb412a9cf30e4d23768d6a"></a><!-- doxytag: member="HFController::byteArrayForSelectedContentsRanges" ref="7fbfe5277deb412a9cf30e4d23768d6a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *) byteArrayForSelectedContentsRanges           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method for creating a byte array containing all of the selected bytes. If the selection has length 0, this returns an empty byte array. 
</div>
</div><p>
<a class="anchor" name="4a075b5f9672ed591f4df05b529523ea"></a><!-- doxytag: member="HFController::setBytesPerColumn:" ref="4a075b5f9672ed591f4df05b529523ea" args="(NSUInteger val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setBytesPerColumn:           </td>
          <td></td>
          <td class="paramtype">(NSUInteger)&nbsp;</td>
          <td class="paramname"> <em>val</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="21b45695d698577bc77f240b4934d84e"></a><!-- doxytag: member="HFController::bytesPerColumn" ref="21b45695d698577bc77f240b4934d84e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSUInteger) bytesPerColumn           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="29520367fc6936a7bea9d2666c048f53"></a><!-- doxytag: member="HFController::inOverwriteMode" ref="29520367fc6936a7bea9d2666c048f53" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) inOverwriteMode           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether this <a class="el" href="interface_h_f_controller.html" title="A central class that acts as the controller layer for HexFiend.framework.">HFController</a> is in overwrite mode or not. 
</div>
</div><p>
<a class="anchor" name="8b5d220244a6172965dd77a988ac10a2"></a><!-- doxytag: member="HFController::setInOverwriteMode:" ref="8b5d220244a6172965dd77a988ac10a2" args="(BOOL val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setInOverwriteMode:           </td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>val</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether we this <a class="el" href="interface_h_f_controller.html" title="A central class that acts as the controller layer for HexFiend.framework.">HFController</a> is in overwrite mode or not. 
</div>
</div><p>
<a class="anchor" name="81a19f92ea49ee1a1099219d3b02f7db"></a><!-- doxytag: member="HFController::requiresOverwriteMode" ref="81a19f92ea49ee1a1099219d3b02f7db" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) requiresOverwriteMode           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns YES if we must be in overwrite mode (because our backing data cannot have its size changed) 
</div>
</div><p>
<a class="anchor" name="62c0d350b8f9e5c0e35e1c676f9198b1"></a><!-- doxytag: member="HFController::displayedLineRange" ref="62c0d350b8f9e5c0e35e1c676f9198b1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_h_f_f_p_range.html">HFFPRange</a>) displayedLineRange           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current displayed line range. The displayed line range is an <a class="el" href="struct_h_f_f_p_range.html" title="HFFPRange is a struct used for representing floating point ranges, similar to NSRange...">HFFPRange</a> (range of long doubles) containing the lines that are currently displayed.<p>
The values may be fractional. That is, if only the bottom half of line 4 through the top two thirds of line 8 is shown, then the displayedLineRange.location will be 4.5 and the displayedLineRange.length will be 3.17 ( = 7.67 - 4.5). Representers are expected to be able to handle such fractional values. 
</div>
</div><p>
<a class="anchor" name="cccd8b4479f2d5f9412e3264fade0bfd"></a><!-- doxytag: member="HFController::setDisplayedLineRange:" ref="cccd8b4479f2d5f9412e3264fade0bfd" args="(HFFPRange range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setDisplayedLineRange:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_f_p_range.html">HFFPRange</a>)&nbsp;</td>
          <td class="paramname"> <em>range</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the displayed line range. When setting the displayed line range, the given range must be nonnegative, and the maximum of the range must be no larger than the total line count. See the -displayedLineRange method for more information. 
</div>
</div><p>
<a class="anchor" name="56a018dd37edf85c0827b1ddb8033c1e"></a><!-- doxytag: member="HFController::maximizeVisibilityOfContentsRange:" ref="56a018dd37edf85c0827b1ddb8033c1e" args="(HFRange range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) maximizeVisibilityOfContentsRange:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td>
          <td class="paramname"> <em>range</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Modify the displayedLineRange as little as possible so that as much of the given range as can fit is visible. 
</div>
</div><p>
<a class="anchor" name="1f6f628d0e41ad0f9d08fcb6e4859ff6"></a><!-- doxytag: member="HFController::centerContentsRange:" ref="1f6f628d0e41ad0f9d08fcb6e4859ff6" args="(HFRange range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) centerContentsRange:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td>
          <td class="paramname"> <em>range</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Modify the displayedLineRange as to center the given contents range. If the range is near the bottom or top, this will center as close as possible. If contents range is too large to fit, it centers the top of the range. contentsRange may be empty. 
</div>
</div><p>
<a class="anchor" name="78f0706546173a0520e100a1aef3d96a"></a><!-- doxytag: member="HFController::font" ref="78f0706546173a0520e100a1aef3d96a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSFont *) font           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current font. 
</div>
</div><p>
<a class="anchor" name="c18fa5735f1e007ca0afaed4d681ee0e"></a><!-- doxytag: member="HFController::setFont:" ref="c18fa5735f1e007ca0afaed4d681ee0e" args="(NSFont *font)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setFont:           </td>
          <td></td>
          <td class="paramtype">(NSFont *)&nbsp;</td>
          <td class="paramname"> <em>font</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the current font. 
</div>
</div><p>
<a class="anchor" name="d1e7a80670e75a7a52e3c661e561f504"></a><!-- doxytag: member="HFController::setUndoManager:" ref="d1e7a80670e75a7a52e3c661e561f504" args="(NSUndoManager *manager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setUndoManager:           </td>
          <td></td>
          <td class="paramtype">(NSUndoManager *)&nbsp;</td>
          <td class="paramname"> <em>manager</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the undo manager for this <a class="el" href="interface_h_f_controller.html" title="A central class that acts as the controller layer for HexFiend.framework.">HFController</a>. By default the undo manager for an <a class="el" href="interface_h_f_controller.html" title="A central class that acts as the controller layer for HexFiend.framework.">HFController</a> is nil. If one is not set, undo does not occur. This retains the undo manager. 
</div>
</div><p>
<a class="anchor" name="b8e21f45fb081eb89144c84c63e4a969"></a><!-- doxytag: member="HFController::undoManager" ref="b8e21f45fb081eb89144c84c63e4a969" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSUndoManager *) undoManager           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the undo manager for this <a class="el" href="interface_h_f_controller.html" title="A central class that acts as the controller layer for HexFiend.framework.">HFController</a>. By default the undo manager is nil. Undo will not be supported unless an undo manager is set. 
</div>
</div><p>
<a class="anchor" name="95b2d736476d323636a032a67e31567f"></a><!-- doxytag: member="HFController::editable" ref="95b2d736476d323636a032a67e31567f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) editable           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the editable property, which determines whether the user can edit the document. 
</div>
</div><p>
<a class="anchor" name="c7b5cc18a47905b21f68e6a38602eacc"></a><!-- doxytag: member="HFController::setEditable:" ref="c7b5cc18a47905b21f68e6a38602eacc" args="(BOOL flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setEditable:           </td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>flag</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the editable property, which determines whether the user can edit the document. 
</div>
</div><p>
<a class="anchor" name="c9daafc45d20b23aee996967db8ff95a"></a><!-- doxytag: member="HFController::shouldAntialias" ref="c9daafc45d20b23aee996967db8ff95a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldAntialias           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether text should be antialiased. 
</div>
</div><p>
<a class="anchor" name="e19015e1d86a43569d9a8d70e01fa4a2"></a><!-- doxytag: member="HFController::setShouldAntialias:" ref="e19015e1d86a43569d9a8d70e01fa4a2" args="(BOOL antialias)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setShouldAntialias:           </td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>antialias</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether text should be antialiased. 
</div>
</div><p>
<a class="anchor" name="897adf82206ac7ff51d88d682c75adb5"></a><!-- doxytag: member="HFController::representer:changedProperties:" ref="897adf82206ac7ff51d88d682c75adb5" args="(HFRepresenter *rep,[changedProperties] HFControllerPropertyBits properties)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) representer:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_representer.html">HFRepresenter</a> *)&nbsp;</td>
          <td class="paramname"> <em>rep</em></td>
        </tr>
        <tr>
          <td class="paramkey">changedProperties:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_h_f_controller_8h.html#dfb5b0d9c70a4b65379361b34ba1aea5">HFControllerPropertyBits</a>)&nbsp;</td>
          <td class="paramname"> <em>properties</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Representer initiated property changes Called from a representer to indicate when some internal property of the representer has changed which requires that some properties be recalculated.<p>
Callback for a representer-initiated change to some property. For example, if some property of a view changes that would cause the number of bytes per line to change, then the representer should call this method which will trigger the <a class="el" href="interface_h_f_controller.html" title="A central class that acts as the controller layer for HexFiend.framework.">HFController</a> to recompute the relevant properties. 
</div>
</div><p>
<a class="anchor" name="fe1ed1781c43e90cd22ac7b2a8f075cd"></a><!-- doxytag: member="HFController::beginSelectionWithEvent:forByteIndex:" ref="fe1ed1781c43e90cd22ac7b2a8f075cd" args="(NSEvent *event,[forByteIndex] unsigned long long byteIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) beginSelectionWithEvent:           </td>
          <td></td>
          <td class="paramtype">(NSEvent *)&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
        </tr>
        <tr>
          <td class="paramkey">forByteIndex:</td>
          <td></td>
          <td class="paramtype">(unsigned long long)&nbsp;</td>
          <td class="paramname"> <em>byteIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin a selection session, with a mouse down at the given byte index. 
</div>
</div><p>
<a class="anchor" name="fef0697a95acb2993f3130fe06e33d1c"></a><!-- doxytag: member="HFController::continueSelectionWithEvent:forByteIndex:" ref="fef0697a95acb2993f3130fe06e33d1c" args="(NSEvent *event,[forByteIndex] unsigned long long byteIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) continueSelectionWithEvent:           </td>
          <td></td>
          <td class="paramtype">(NSEvent *)&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
        </tr>
        <tr>
          <td class="paramkey">forByteIndex:</td>
          <td></td>
          <td class="paramtype">(unsigned long long)&nbsp;</td>
          <td class="paramname"> <em>byteIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Continue a selection session, whe the user drags over the given byte index. 
</div>
</div><p>
<a class="anchor" name="2334cbd36d1c2db533b923dee6dd6227"></a><!-- doxytag: member="HFController::endSelectionWithEvent:forByteIndex:" ref="2334cbd36d1c2db533b923dee6dd6227" args="(NSEvent *event,[forByteIndex] unsigned long long byteIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) endSelectionWithEvent:           </td>
          <td></td>
          <td class="paramtype">(NSEvent *)&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
        </tr>
        <tr>
          <td class="paramkey">forByteIndex:</td>
          <td></td>
          <td class="paramtype">(unsigned long long)&nbsp;</td>
          <td class="paramname"> <em>byteIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
End a selection session, with a mouse up at the given byte index. 
</div>
</div><p>
<a class="anchor" name="d360138919e9089c6edd7868a318bb93"></a><!-- doxytag: member="HFController::scrollWithScrollEvent:" ref="d360138919e9089c6edd7868a318bb93" args="(NSEvent *scrollEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) scrollWithScrollEvent:           </td>
          <td></td>
          <td class="paramtype">(NSEvent *)&nbsp;</td>
          <td class="paramname"> <em>scrollEvent</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Trigger scrolling appropriate for the given scroll event. 
</div>
</div><p>
<a class="anchor" name="101555ad8fbdad75022ba0ad59c43cc3"></a><!-- doxytag: member="HFController::scrollByLines:" ref="101555ad8fbdad75022ba0ad59c43cc3" args="(long double lines)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) scrollByLines:           </td>
          <td></td>
          <td class="paramtype">(long double)&nbsp;</td>
          <td class="paramname"> <em>lines</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Trigger scrolling by the given number of lines. If lines is positive, then the document is scrolled down; otherwise it is scrolled up. 
</div>
</div><p>
<a class="anchor" name="1c9891714d90d45b21443183f3e18612"></a><!-- doxytag: member="HFController::moveInDirection:byByteCount:withSelectionTransformation:usingAnchor:" ref="1c9891714d90d45b21443183f3e18612" args="(HFControllerMovementDirection direction,[byByteCount] unsigned long long amountToMove,[withSelectionTransformation] HFControllerSelectionTransformation transformation,[usingAnchor] BOOL useAnchor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) moveInDirection:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_h_f_controller_8h.html#375dde7ced2bf775954f9e950eec3add">HFControllerMovementDirection</a>)&nbsp;</td>
          <td class="paramname"> <em>direction</em></td>
        </tr>
        <tr>
          <td class="paramkey">byByteCount:</td>
          <td></td>
          <td class="paramtype">(unsigned long long)&nbsp;</td>
          <td class="paramname"> <em>amountToMove</em></td>
        </tr>
        <tr>
          <td class="paramkey">withSelectionTransformation:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_h_f_controller_8h.html#5439328d873d33dd7baf4622c28a513f">HFControllerSelectionTransformation</a>)&nbsp;</td>
          <td class="paramname"> <em>transformation</em></td>
        </tr>
        <tr>
          <td class="paramkey">usingAnchor:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>useAnchor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
General purpose navigation function. Modify the selection in the given direction by the given number of bytes. The selection is modifed according to the given transformation. If useAnchor is set, then anchored selection is used; otherwise any anchor is discarded.<p>
This has a few limitations:<ul>
<li>Only HFControllerDirectionLeft and HFControllerDirectionRight movement directions are supported.</li><li>Anchored selection is not supported for HFControllerShiftSelection (useAnchor must be NO) </li></ul>

</div>
</div><p>
<a class="anchor" name="f55799f6dcf1e8ea6d52a63d11913e4d"></a><!-- doxytag: member="HFController::moveInDirection:withGranularity:andModifySelection:" ref="f55799f6dcf1e8ea6d52a63d11913e4d" args="(HFControllerMovementDirection direction,[withGranularity] HFControllerMovementGranularity granularity,[andModifySelection] BOOL extendSelection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) moveInDirection:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_h_f_controller_8h.html#375dde7ced2bf775954f9e950eec3add">HFControllerMovementDirection</a>)&nbsp;</td>
          <td class="paramname"> <em>direction</em></td>
        </tr>
        <tr>
          <td class="paramkey">withGranularity:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_h_f_controller_8h.html#f7604c610ec5c06d5e9f65ae96fb6aa4">HFControllerMovementGranularity</a>)&nbsp;</td>
          <td class="paramname"> <em>granularity</em></td>
        </tr>
        <tr>
          <td class="paramkey">andModifySelection:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>extendSelection</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Navigation designed for key events. 
</div>
</div><p>
<a class="anchor" name="2d2eea7b16f6fd019f949cdbf953a2d4"></a><!-- doxytag: member="HFController::moveToLineBoundaryInDirection:andModifySelection:" ref="2d2eea7b16f6fd019f949cdbf953a2d4" args="(HFControllerMovementDirection direction,[andModifySelection] BOOL extendSelection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) moveToLineBoundaryInDirection:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_h_f_controller_8h.html#375dde7ced2bf775954f9e950eec3add">HFControllerMovementDirection</a>)&nbsp;</td>
          <td class="paramname"> <em>direction</em></td>
        </tr>
        <tr>
          <td class="paramkey">andModifySelection:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>extendSelection</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="14b1e57bd37c4b9b4f7efc78feff5cc7"></a><!-- doxytag: member="HFController::insertByteArray:replacingPreviousBytes:allowUndoCoalescing:" ref="14b1e57bd37c4b9b4f7efc78feff5cc7" args="(HFByteArray *byteArray,[replacingPreviousBytes] unsigned long long previousByteCount,[allowUndoCoalescing] BOOL allowUndoCoalescing)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) insertByteArray:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *)&nbsp;</td>
          <td class="paramname"> <em>byteArray</em></td>
        </tr>
        <tr>
          <td class="paramkey">replacingPreviousBytes:</td>
          <td></td>
          <td class="paramtype">(unsigned long long)&nbsp;</td>
          <td class="paramname"> <em>previousByteCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">allowUndoCoalescing:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>allowUndoCoalescing</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replaces the selection with the given data. For something like a hex view representer, it takes two keypresses to create a whole byte; the way this is implemented, the first keypress goes into the data as a complete byte, and the second one (if any) replaces it. If previousByteCount &gt; 0, then that many prior bytes are replaced, without breaking undo coalescing. For previousByteCount to be &gt; 0, the following must be true: There is only one selected range, and it is of length 0, and its location &gt;= previousByteCount<p>
These functions return YES if they succeed, and NO if they fail. Currently they may fail only in overwrite mode, if you attempt to insert data that would require lengthening the byte array.<p>
These methods are undoable. 
</div>
</div><p>
<a class="anchor" name="699f5ef88349ffda1475e7a18b072f30"></a><!-- doxytag: member="HFController::insertData:replacingPreviousBytes:allowUndoCoalescing:" ref="699f5ef88349ffda1475e7a18b072f30" args="(NSData *data,[replacingPreviousBytes] unsigned long long previousByteCount,[allowUndoCoalescing] BOOL allowUndoCoalescing)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) insertData:           </td>
          <td></td>
          <td class="paramtype">(NSData *)&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
        </tr>
        <tr>
          <td class="paramkey">replacingPreviousBytes:</td>
          <td></td>
          <td class="paramtype">(unsigned long long)&nbsp;</td>
          <td class="paramname"> <em>previousByteCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">allowUndoCoalescing:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>allowUndoCoalescing</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f00b1ffb077f9a69e4e81271e2326a65"></a><!-- doxytag: member="HFController::deleteSelection" ref="f00b1ffb077f9a69e4e81271e2326a65" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) deleteSelection           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the selection. This operation is undoable. 
</div>
</div><p>
<a class="anchor" name="3ab4cca9b78f0d7654a7a47a8f5d3348"></a><!-- doxytag: member="HFController::deleteDirection:" ref="3ab4cca9b78f0d7654a7a47a8f5d3348" args="(HFControllerMovementDirection direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) deleteDirection:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_h_f_controller_8h.html#375dde7ced2bf775954f9e950eec3add">HFControllerMovementDirection</a>)&nbsp;</td>
          <td class="paramname"> <em>direction</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the selection is empty, deletes one byte in a given direction, which must be HFControllerDirectionLeft or HFControllerDirectionRight; if the selection is not empty, deletes the selection. Undoable. 
</div>
</div><p>
<a class="anchor" name="1cde2c2c601a6093183bf5d46744e41c"></a><!-- doxytag: member="HFController::dataForRange:" ref="1cde2c2c601a6093183bf5d46744e41c" args="(HFRange range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSData *) dataForRange:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td>
          <td class="paramname"> <em>range</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an NSData representing the given <a class="el" href="struct_h_f_range.html" title="HFRange is the 64 bit analog of NSRange, containing a 64 bit location and length...">HFRange</a>. The length of the <a class="el" href="struct_h_f_range.html" title="HFRange is the 64 bit analog of NSRange, containing a 64 bit location and length...">HFRange</a> must be of a size that can reasonably be fit in memory. This method may cache the result. 
</div>
</div><p>
<a class="anchor" name="a2079ff054de49c61e2ac36f8db046e0"></a><!-- doxytag: member="HFController::copyBytes:range:" ref="a2079ff054de49c61e2ac36f8db046e0" args="(unsigned char *bytes,[range] HFRange range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) copyBytes:           </td>
          <td></td>
          <td class="paramtype">(unsigned char *)&nbsp;</td>
          <td class="paramname"> <em>bytes</em></td>
        </tr>
        <tr>
          <td class="paramkey">range:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td>
          <td class="paramname"> <em>range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies data within the given <a class="el" href="struct_h_f_range.html" title="HFRange is the 64 bit analog of NSRange, containing a 64 bit location and length...">HFRange</a> into an in-memory buffer. This is equivalent to [[controller byteArray] copyBytes:bytes range:range]. 
</div>
</div><p>
<a class="anchor" name="e6f97f85a07846c175eec9d120b7ab0c"></a><!-- doxytag: member="HFController::byteRangeAttributeArray" ref="e6f97f85a07846c175eec9d120b7ab0c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_h_f_byte_range_attribute_array.html">HFByteRangeAttributeArray</a> *) byteRangeAttributeArray           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method that returns the attributes of the underlying byte array. You can message it directly to add and remove attributes. If you do so, be sure to call representer:changedProperties: with the HFControllerByteRangeAttributes bit 
</div>
</div><p>
<a class="anchor" name="ee334d276545d87999f50068d92fdbc9"></a><!-- doxytag: member="HFController::attributesForBytesInRange:" ref="ee334d276545d87999f50068d92fdbc9" args="(HFRange range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_h_f_byte_range_attribute_array.html">HFByteRangeAttributeArray</a> *) attributesForBytesInRange:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td>
          <td class="paramname"> <em>range</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the attributes for the given range. This is a union of the receiver's byteRangeAttributeArray properties and the properties returned by the byte array itself. range.length must be &lt;= NSUIntegerMax. 
</div>
</div><p>
<a class="anchor" name="f9c1dd8642e2699e3905607af4baebda"></a><!-- doxytag: member="HFController::rangeForBookmark:" ref="f9c1dd8642e2699e3905607af4baebda" args="(NSInteger bookmark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_h_f_range.html">HFRange</a>) rangeForBookmark:           </td>
          <td></td>
          <td class="paramtype">(NSInteger)&nbsp;</td>
          <td class="paramname"> <em>bookmark</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the range for the given bookmark. If there is no bookmark, returns {ULLONG_MAX, ULLONG_MAX}. 
</div>
</div><p>
<a class="anchor" name="e422bac1d7fa0bd6a23af4da72bdb659"></a><!-- doxytag: member="HFController::setRange:forBookmark:" ref="e422bac1d7fa0bd6a23af4da72bdb659" args="(HFRange range,[forBookmark] NSInteger bookmark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setRange:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td>
          <td class="paramname"> <em>range</em></td>
        </tr>
        <tr>
          <td class="paramkey">forBookmark:</td>
          <td></td>
          <td class="paramtype">(NSInteger)&nbsp;</td>
          <td class="paramname"> <em>bookmark</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the range for the given bookmark. Pass {ULLONG_MAX, ULLONG_MAX} to remove the bookmark. Undoable. 
</div>
</div><p>
<a class="anchor" name="2d070cf8360a9a5caf0ecabcb68e826e"></a><!-- doxytag: member="HFController::bookmarksInRange:" ref="2d070cf8360a9a5caf0ecabcb68e826e" args="(HFRange range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSIndexSet *) bookmarksInRange:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td>
          <td class="paramname"> <em>range</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an NSIndexSet of the bookmarks in the given range. 
</div>
</div><p>
<a class="anchor" name="63873f2b9439048b9ba1c406ec033b44"></a><!-- doxytag: member="HFController::contentsLength" ref="63873f2b9439048b9ba1c406ec033b44" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (unsigned long long) contentsLength           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns total number of bytes. This is equivalent to [[controller byteArray] length]. 
</div>
</div><p>
<a class="anchor" name="1a11f43ce26f5c2dbfcf447d6c5470eb"></a><!-- doxytag: member="HFController::prepareForChangeInFile:fromWritingByteArray:" ref="1a11f43ce26f5c2dbfcf447d6c5470eb" args="(NSURL *targetFile,[fromWritingByteArray] HFByteArray *array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (BOOL) prepareForChangeInFile:           </td>
          <td></td>
          <td class="paramtype">(NSURL *)&nbsp;</td>
          <td class="paramname"> <em>targetFile</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromWritingByteArray:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *)&nbsp;</td>
          <td class="paramname"> <em>array</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempts to clear all dependencies on the given file (clipboard, undo, etc.) that could not be preserved if the file were written. Returns YES if we successfully prepared, NO if someone objected. This works by posting a HFPrepareForChangeInFileNotification. <a class="el" href="interface_h_f_controller.html" title="A central class that acts as the controller layer for HexFiend.framework.">HFController</a> does not register for this notification: instead the owners of the <a class="el" href="interface_h_f_controller.html" title="A central class that acts as the controller layer for HexFiend.framework.">HFController</a> are expected to register for HFPrepareForChangeInFileNotification and react appropriately. 
</div>
</div><p>
<a class="anchor" name="73c224051475a997711192269714a0bf"></a><!-- doxytag: member="HFController::clearUndoManagerDependenciesOnRanges:inFile:hint:" ref="73c224051475a997711192269714a0bf" args="(NSArray *ranges,[inFile] HFFileReference *reference,[hint] NSMutableDictionary *hint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) clearUndoManagerDependenciesOnRanges:           </td>
          <td></td>
          <td class="paramtype">(NSArray *)&nbsp;</td>
          <td class="paramname"> <em>ranges</em></td>
        </tr>
        <tr>
          <td class="paramkey">inFile:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_file_reference.html">HFFileReference</a> *)&nbsp;</td>
          <td class="paramname"> <em>reference</em></td>
        </tr>
        <tr>
          <td class="paramkey">hint:</td>
          <td></td>
          <td class="paramtype">(NSMutableDictionary *)&nbsp;</td>
          <td class="paramname"> <em>hint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempts to break undo stack dependencies for writing the given file. If it is unable to do so, it will clear the controller's contributions to the stack. Returns YES if it successfully broke the dependencies, and NO if the stack had to be cleared. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_h_f_controller_8h_source.html">HFController.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Dec 8 10:06:35 2011 for HexFiend by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
