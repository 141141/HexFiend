<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>HexFiend: HFByteSlice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>HFByteSlice Class Reference<br>
<small>
[<a class="el" href="group__model.html">Model</a>]</small>
</h1><!-- doxytag: class="HFByteSlice" -->A class representing a source of data for an <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a>.  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for HFByteSlice:</div>
<div class="dynsection">

<p><center><img src="interface_h_f_byte_slice.png" usemap="#HFByteSlice_map" border="0" alt=""></center>
<map name="HFByteSlice_map">
<area href="interface_h_f_file_byte_slice.html" alt="HFFileByteSlice" shape="rect" coords="0,56,174,80">
<area href="interface_h_f_full_memory_byte_slice.html" alt="HFFullMemoryByteSlice" shape="rect" coords="184,56,358,80">
<area href="interface_h_f_process_memory_byte_slice.html" alt="HFProcessMemoryByteSlice" shape="rect" coords="368,56,542,80">
<area href="interface_h_f_shared_memory_byte_slice.html" alt="HFSharedMemoryByteSlice" shape="rect" coords="552,56,726,80">
</map>
</div>

<p>
<a href="class_h_f_byte_slice-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(unsigned long long)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_slice.html#145b439ab365eba8387f6f39c9558ad6">length</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_slice.html#dae2c54726d7bd02884410a8701b1ccf">copyBytes:range:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(<a class="el" href="interface_h_f_byte_slice.html">HFByteSlice</a> *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_slice.html#955b9f5a9ca54031c6d2b185c3adbef1">subsliceWithRange:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(id)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_slice.html#d665b355b8b255ca113020be71ef062f">byteSliceByAppendingSlice:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_slice.html#e09995093b464c0016dc1337dc5124df">isSourcedFromFile</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_slice.html#0bb3be9593aed4f2ddaa24b50ac818da">sourceRangeForFile:</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="interface_h_f_byte_slice.html" title="A class representing a source of data for an HFByteArray.">HFByteSlice</a> is an abstract class encapsulating primitive data sources (files, memory buffers, etc.). Each source must support random access reads, and have a well defined length. All HFByteSlices are <b>immutable</b>.<p>
The two principal subclasses of <a class="el" href="interface_h_f_byte_slice.html" title="A class representing a source of data for an HFByteArray.">HFByteSlice</a> are <a class="el" href="interface_h_f_shared_memory_byte_slice.html" title="A subclass of HFByteSlice for working with data stored in memory.">HFSharedMemoryByteSlice</a> and <a class="el" href="interface_h_f_file_byte_slice.html" title="A subclass of HFByteSlice for working data stored in files.">HFFileByteSlice</a>, which respectively encapsulate data from memory and from a file. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="145b439ab365eba8387f6f39c9558ad6"></a><!-- doxytag: member="HFByteSlice::length" ref="145b439ab365eba8387f6f39c9558ad6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (unsigned long long) length           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the length of the byte slice as a 64 bit value. This is an abstract method that concrete subclasses must override. 
</div>
</div><p>
<a class="anchor" name="dae2c54726d7bd02884410a8701b1ccf"></a><!-- doxytag: member="HFByteSlice::copyBytes:range:" ref="dae2c54726d7bd02884410a8701b1ccf" args="(unsigned char *dst,[range] HFRange range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) copyBytes:           </td>
          <td></td>
          <td class="paramtype">(unsigned char *)&nbsp;</td>
          <td class="paramname"> <em>dst</em></td>
        </tr>
        <tr>
          <td class="paramkey">range:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td>
          <td class="paramname"> <em>range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies a range of data from the byte slice into an in-memory buffer. This is an abstract method that concrete subclasses must override. 
</div>
</div><p>
<a class="anchor" name="955b9f5a9ca54031c6d2b185c3adbef1"></a><!-- doxytag: member="HFByteSlice::subsliceWithRange:" ref="955b9f5a9ca54031c6d2b185c3adbef1" args="(HFRange range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_h_f_byte_slice.html">HFByteSlice</a> *) subsliceWithRange:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td>
          <td class="paramname"> <em>range</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a new slice containing a subrange of the given slice. This is an abstract method that concrete subclasses must override. 
</div>
</div><p>
<a class="anchor" name="d665b355b8b255ca113020be71ef062f"></a><!-- doxytag: member="HFByteSlice::byteSliceByAppendingSlice:" ref="d665b355b8b255ca113020be71ef062f" args="(HFByteSlice *slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) byteSliceByAppendingSlice:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_byte_slice.html">HFByteSlice</a> *)&nbsp;</td>
          <td class="paramname"> <em>slice</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempts to create a new byte slice by appending one byte slice to another. This does not modify the receiver or the slice argument (after all, both are immutable). This is provided as an optimization, and is allowed to return nil if the appending cannot be done efficiently. The default implementation returns nil. 
</div>
</div><p>
<a class="anchor" name="e09995093b464c0016dc1337dc5124df"></a><!-- doxytag: member="HFByteSlice::isSourcedFromFile" ref="e09995093b464c0016dc1337dc5124df" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isSourcedFromFile           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns YES if the receiver is sourced from a file. The default implementation returns NO. This is used to estimate cost when writing to a file. 
</div>
</div><p>
<a class="anchor" name="0bb3be9593aed4f2ddaa24b50ac818da"></a><!-- doxytag: member="HFByteSlice::sourceRangeForFile:" ref="0bb3be9593aed4f2ddaa24b50ac818da" args="(HFFileReference *reference)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_h_f_range.html">HFRange</a>) sourceRangeForFile:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_file_reference.html">HFFileReference</a> *)&nbsp;</td>
          <td class="paramname"> <em>reference</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For a given file reference, returns the range within the file that the receiver is sourced from. If the receiver is not sourced from this file, returns {ULLONG_MAX, ULLONG_MAX}. The default implementation returns {ULLONG_MAX, ULLONG_MAX}. This is used during file saving to to determine how to properly overwrite a given file. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_h_f_byte_slice_8h_source.html">HFByteSlice.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Dec 8 10:06:35 2011 for HexFiend by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
