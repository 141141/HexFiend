<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>HexFiend: HFByteArray Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>HFByteArray Class Reference<br>
<small>
[<a class="el" href="group__model.html">Model</a>]</small>
</h1><!-- doxytag: class="HFByteArray" -->The principal Model class for HexFiend's MVC architecture.  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for HFByteArray:</div>
<div class="dynsection">

<p><center><img src="interface_h_f_byte_array.png" usemap="#HFByteArray_map" border="0" alt=""></center>
<map name="HFByteArray_map">
<area href="interface_h_f_attributed_byte_array.html" alt="HFAttributedByteArray" shape="rect" coords="0,56,154,80">
<area href="interface_h_f_b_tree_byte_array.html" alt="HFBTreeByteArray" shape="rect" coords="164,56,318,80">
<area href="interface_h_f_full_memory_byte_array.html" alt="HFFullMemoryByteArray" shape="rect" coords="328,56,482,80">
</map>
</div>

<p>
<a href="class_h_f_byte_array-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing raw data</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(unsigned long long)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#da079f9ec02547a52439f03d03c22491">length</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#f6766ba88422def2964ef186c9e98f54">copyBytes:range:</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Accessing byte slices</div></td></tr>
<tr><td colspan="2"><div class="groupText">Methods to access the byte slices underlying the <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a>. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#d5bc7decb596b958f03659fecc8ab2cf">byteSlices</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSEnumerator *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#97980272d1583849b2ba0db9c3d28448">byteSliceEnumerator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(<a class="el" href="interface_h_f_byte_slice.html">HFByteSlice</a> *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#bd1a2d2233f40e10750ac8203e25e0c4">sliceContainingByteAtIndex:beginningOffset:</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Modifying the byte array</div></td></tr>
<tr><td colspan="2"><div class="groupText">Methods to modify the given byte array. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#c742834b33b8a7d67e33b45bd63b6c7a">insertByteSlice:inRange:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#fea8d32ef5f668aae33368e7a8bedfb8">insertByteArray:inRange:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#2d706967a198c9ce83927aac0b1a8e53">deleteBytesInRange:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#6b8cac4d751fbc61456630ee141beb64">subarrayWithRange:</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Write locking and generation count</div></td></tr>
<tr><td colspan="2"><div class="groupText">Methods to lock and query the lock that prevents writes. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#521cf2a05fdafc70b3b78c4f2bfa05ad">incrementChangeLockCounter</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#48d930eebf0df5ec921678feadc84388">decrementChangeLockCounter</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#7b940818a34e5fc956cc05aacdd6e200">changesAreLocked</a></td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#c3b8df15c725a674b382b8869f0311d6">incrementGenerationOrRaiseIfLockedForSelector:</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSUInteger)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#fd62e6b3be8b05596494c5fbb7d7ea0f">changeGenerationCount</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Searching</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(unsigned long long)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#0c325f05d3cbf5a915bd60d96a5c4546">indexOfBytesEqualToBytes:inRange:searchingForwards:trackingProgress:</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a> implements the Model portion of HexFiend.framework. It is logically a mutable, resizable array of bytes, with a 64 bit length. It is somewhat analagous to a 64 bit version of NSMutableData, except that it is designed to enable efficient (faster than O(n)) implementations of insertion and deletion.<p>
<a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a>, being an abstract class, will raise an exception if you attempt to instantiate it directly. For most uses, instantiate <a class="el" href="interface_h_f_b_tree_byte_array.html" title="The principal efficient implementation of HFByteArray.">HFBTreeByteArray</a> instead, with the usual <code>[[class alloc] init]</code>.<p>
<a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a> also exposes itself as an array of <a class="el" href="interface_h_f_byte_slice.html">HFByteSlices</a>, which are logically immutable arrays of bytes. which is useful for operations such as file saving that need to access the underlying byte slices.<p>
<a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a> contains a generation count, which is incremented whenever the <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a> changes (to allow caches to be implemented on top of it). It also includes the notion of locking: a locked <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a> will raise an exception if written to, but it may still be read.<p>
ByteArrays have the usual threading restrictions for non-concurrent data structures. It is safe to read an <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a> concurrently from multiple threads. It is not safe to read an <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a> while it is being modified from another thread, nor is it safe to modify one simultaneously from two threads.<p>
<a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a> is an abstract class. It will raise an exception if you attempt to instantiate it directly. The principal concrete subclass is <a class="el" href="interface_h_f_b_tree_byte_array.html" title="The principal efficient implementation of HFByteArray.">HFBTreeByteArray</a>. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="da079f9ec02547a52439f03d03c22491"></a><!-- doxytag: member="HFByteArray::length" ref="da079f9ec02547a52439f03d03c22491" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (unsigned long long) length           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the length of the <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a> as a 64 bit unsigned long long. This is an abstract method that concrete subclasses must override. 
</div>
</div><p>
<a class="anchor" name="f6766ba88422def2964ef186c9e98f54"></a><!-- doxytag: member="HFByteArray::copyBytes:range:" ref="f6766ba88422def2964ef186c9e98f54" args="(unsigned char *dst,[range] HFRange range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) copyBytes:           </td>
          <td></td>
          <td class="paramtype">(unsigned char *)&nbsp;</td>
          <td class="paramname"> <em>dst</em></td>
        </tr>
        <tr>
          <td class="paramkey">range:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td>
          <td class="paramname"> <em>range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies a range of bytes into a buffer. This is an abstract method that concrete subclasses must override. 
</div>
</div><p>
<a class="anchor" name="d5bc7decb596b958f03659fecc8ab2cf"></a><!-- doxytag: member="HFByteArray::byteSlices" ref="d5bc7decb596b958f03659fecc8ab2cf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) byteSlices           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the contents of the receiver as an array of byte slices. This is an abstract method that concrete subclasses must override. 
</div>
</div><p>
<a class="anchor" name="97980272d1583849b2ba0db9c3d28448"></a><!-- doxytag: member="HFByteArray::byteSliceEnumerator" ref="97980272d1583849b2ba0db9c3d28448" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSEnumerator *) byteSliceEnumerator           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an NSEnumerator representing the byte slices of the receiver. This is implemented as enumerating over the result of -byteSlices, but subclasses can override this to be more efficient. 
</div>
</div><p>
<a class="anchor" name="bd1a2d2233f40e10750ac8203e25e0c4"></a><!-- doxytag: member="HFByteArray::sliceContainingByteAtIndex:beginningOffset:" ref="bd1a2d2233f40e10750ac8203e25e0c4" args="(unsigned long long offset,[beginningOffset] unsigned long long *actualOffset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_h_f_byte_slice.html">HFByteSlice</a> *) sliceContainingByteAtIndex:           </td>
          <td></td>
          <td class="paramtype">(unsigned long long)&nbsp;</td>
          <td class="paramname"> <em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">beginningOffset:</td>
          <td></td>
          <td class="paramtype">(unsigned long long *)&nbsp;</td>
          <td class="paramname"> <em>actualOffset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the byte slice containing the byte at the given index, and the actual offset of this slice. 
</div>
</div><p>
<a class="anchor" name="c742834b33b8a7d67e33b45bd63b6c7a"></a><!-- doxytag: member="HFByteArray::insertByteSlice:inRange:" ref="c742834b33b8a7d67e33b45bd63b6c7a" args="(HFByteSlice *slice,[inRange] HFRange lrange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) insertByteSlice:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_byte_slice.html">HFByteSlice</a> *)&nbsp;</td>
          <td class="paramname"> <em>slice</em></td>
        </tr>
        <tr>
          <td class="paramkey">inRange:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td>
          <td class="paramname"> <em>lrange</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert an <a class="el" href="interface_h_f_byte_slice.html" title="A class representing a source of data for an HFByteArray.">HFByteSlice</a> in the given range. The maximum value of the range must not exceed the length of the subarray. The length of the given slice is not required to be equal to length of the range - in other words, this method may change the length of the receiver. This is an abstract method that concrete subclasses must override. 
</div>
</div><p>
<a class="anchor" name="fea8d32ef5f668aae33368e7a8bedfb8"></a><!-- doxytag: member="HFByteArray::insertByteArray:inRange:" ref="fea8d32ef5f668aae33368e7a8bedfb8" args="(HFByteArray *array,[inRange] HFRange lrange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) insertByteArray:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *)&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
        </tr>
        <tr>
          <td class="paramkey">inRange:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td>
          <td class="paramname"> <em>lrange</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert an <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a> in the given range. This is implemented via calling <code>insertByteSlice:inRange:</code> with the byte slices from the given byte array. 
</div>
</div><p>
<a class="anchor" name="2d706967a198c9ce83927aac0b1a8e53"></a><!-- doxytag: member="HFByteArray::deleteBytesInRange:" ref="2d706967a198c9ce83927aac0b1a8e53" args="(HFRange range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) deleteBytesInRange:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td>
          <td class="paramname"> <em>range</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete bytes in the given range. This is implemented on the base class by creating an empty byte array and inserting it in the range to be deleted, via <code>insertByteSlice:inRange:</code>. 
</div>
</div><p>
<a class="anchor" name="6b8cac4d751fbc61456630ee141beb64"></a><!-- doxytag: member="HFByteArray::subarrayWithRange:" ref="6b8cac4d751fbc61456630ee141beb64" args="(HFRange range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *) subarrayWithRange:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td>
          <td class="paramname"> <em>range</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a new <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a> containing the given range. This is an abstract method that concrete subclasses must override. 
</div>
</div><p>
<a class="anchor" name="521cf2a05fdafc70b3b78c4f2bfa05ad"></a><!-- doxytag: member="HFByteArray::incrementChangeLockCounter" ref="521cf2a05fdafc70b3b78c4f2bfa05ad" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) incrementChangeLockCounter           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Increment the change lock. Until the change lock reaches 0, all modifications to the receiver will raise an exception. 
</div>
</div><p>
<a class="anchor" name="48d930eebf0df5ec921678feadc84388"></a><!-- doxytag: member="HFByteArray::decrementChangeLockCounter" ref="48d930eebf0df5ec921678feadc84388" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) decrementChangeLockCounter           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decrement the change lock. If the change lock reaches 0, modifications will be allowed again. 
</div>
</div><p>
<a class="anchor" name="7b940818a34e5fc956cc05aacdd6e200"></a><!-- doxytag: member="HFByteArray::changesAreLocked" ref="7b940818a34e5fc956cc05aacdd6e200" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) changesAreLocked           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query if the changes are locked. This method is KVO compliant. 
</div>
</div><p>
<a class="anchor" name="c3b8df15c725a674b382b8869f0311d6"></a><!-- doxytag: member="HFByteArray::incrementGenerationOrRaiseIfLockedForSelector:" ref="c3b8df15c725a674b382b8869f0311d6" args="(SEL sel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) incrementGenerationOrRaiseIfLockedForSelector:           </td>
          <td></td>
          <td class="paramtype">(SEL)&nbsp;</td>
          <td class="paramname"> <em>sel</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Increments the generation count, unless the receiver is locked, in which case it raises an exception. All subclasses of <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a> should call this method at the beginning of any overridden method that may modify the receiver. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sel</em>&nbsp;</td><td>The selector that would modify the receiver (e.g. <code>deleteBytesInRange:</code>). This is usually <code>_cmd</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fd62e6b3be8b05596494c5fbb7d7ea0f"></a><!-- doxytag: member="HFByteArray::changeGenerationCount" ref="fd62e6b3be8b05596494c5fbb7d7ea0f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSUInteger) changeGenerationCount           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the change generation count. Every change to the ByteArray increments this by one or more. This can be used for caching layers on top of <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a>, to known when to expire their cache. 
</div>
</div><p>
<a class="anchor" name="0c325f05d3cbf5a915bd60d96a5c4546"></a><!-- doxytag: member="HFByteArray::indexOfBytesEqualToBytes:inRange:searchingForwards:trackingProgress:" ref="0c325f05d3cbf5a915bd60d96a5c4546" args="(HFByteArray *findBytes,[inRange] HFRange range,[searchingForwards] BOOL forwards,[trackingProgress] HFProgressTracker *progressTracker)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (unsigned long long) indexOfBytesEqualToBytes:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *)&nbsp;</td>
          <td class="paramname"> <em>findBytes</em></td>
        </tr>
        <tr>
          <td class="paramkey">inRange:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&nbsp;</td>
          <td class="paramname"> <em>range</em></td>
        </tr>
        <tr>
          <td class="paramkey">searchingForwards:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>forwards</em></td>
        </tr>
        <tr>
          <td class="paramkey">trackingProgress:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_progress_tracker.html">HFProgressTracker</a> *)&nbsp;</td>
          <td class="paramname"> <em>progressTracker</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches the receiver for a byte array matching findBytes within the given range, and returns the index that it was found. This is a concrete method on <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>findBytes</em>&nbsp;</td><td>The <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture.">HFByteArray</a> containing the data to be found (the needle to the receiver's haystack). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>range</em>&nbsp;</td><td>The range of the receiver in which to search. The end of the range must not exceed the receiver's length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>forwards</em>&nbsp;</td><td>If this is YES, then the first match within the range is returned. Otherwise the last is returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>progressTracker</em>&nbsp;</td><td>An <a class="el" href="interface_h_f_progress_tracker.html" title="A class that helps handle progress indication and cancellation for long running threaded...">HFProgressTracker</a> to allow progress reporting and cancelleation for the search operation. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The index in the receiver of bytes equal to <code>findBytes</code>, or ULLONG_MAX if the byte array was not found (or the operation was cancelled) </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_h_f_byte_array_8h_source.html">HFByteArray.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Dec 8 10:06:35 2011 for HexFiend by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
